# TOPIC 04: Discrete Math and Number Theory

## Basic Math
### Sum Formulas
#### **Arithmetic Progression (AP)**

$$S_n = \sum_{k=1}^{n} [a + (k-1)d]$$

An **Arithmetic Progression (AP)** is a sequence of numbers where the difference between any two consecutive terms is constant. This constant value is called the **common difference ($d$)**.

In simple terms, you get from one term to the next by always adding the same number.

* **Example**: The sequence **5, 9, 13, 17, 21, ...** is an arithmetic progression.
    * The **first term ($a$)** is 5.
    * The **common difference ($d$)** is 4 (since 9 - 5 = 4, 13 - 9 = 4, and so on).

The core idea is predictable, linear growth.

Let **$a$** be the first term, **$d$** be the common difference, and **$n$** be the term number.

* **To find the $n$-th term ($a_n$) of the sequence:**
    $$
    a_n = a + (n-1)d
    $$

* **To find the sum of the first $n$ terms ($S_n$):**
    $$
    S_n = \frac{n}{2}[2a + (n-1)d]
    $$
    Alternatively, if you know the **last term ($a_n$)**, the sum formula is even simpler:
    $$
    S_n = \frac{n}{2}(a + a_n)
    $$

#### **Geometric Progression (GP)**

$$S_n = \sum_{k=1}^{n} ar^{k-1}$$

A **Geometric Progression** is a sequence where each term after the first is found by multiplying the previous one by a fixed, non-zero number. This number is called the **common ratio ($r$)**.

* **Example**: 3, 6, 12, 24, ... (The common ratio is 2).

The sum of the first $n$ terms ($S_n$) is given by:
$$S_n = a \frac{1 - r^n}{1 - r} \quad (\text{where } r \neq 1)$$

For an **infinite** geometric progression, the sum converges to a finite value only if the absolute value of the common ratio is less than 1 (i.e., $|r| < 1$). The formula is:
$$S_\infty = \frac{a}{1 - r}$$


#### **Harmonic Progression (HP) **

$$S_n = \sum_{k=1}^{n} \frac{1}{a + (k-1)d}$$

A **Harmonic Progression** is a sequence of numbers whose **reciprocals** form an Arithmetic Progression.

* **Example**: $\frac{1}{5}, \frac{1}{8}, \frac{1}{11}, \frac{1}{14}, \dots$ (The reciprocals 5, 8, 11, 14, ... form an AP).

There is **no simple, direct formula** to calculate the sum of a Harmonic Progression. To find the sum, you must calculate each term individually and then add them up.

Of course. Here are the summation formulas for each progression expressed using Sigma ($\Sigma$) notation.

### Set Theory
**Set theory** is a branch of mathematics that studies sets, which are collections of distinct objects.

A **set** is an unordered collection of unique items, called **elements**. The order of elements doesn't matter, and duplicate elements are ignored. Sets are typically written using curly braces ${}$.

* **Example**: $A = {1, 3, 5, 7}$. Here, $3$ is an element of set A, written as $3 ∈ A$.

#### **Set Theory Concepts**
* **Universal Set ($U$)**: The set of all possible elements within a specific context.
* **Empty Set ($\emptyset$)**: A set with no elements, denoted as ${}$ or $∅$.
* **Subset ($⊆$)**: $A ⊆ B$ means all elements of set A are also in set B.
* **Proper Subset ($⊂$)**: $A ⊂ B$ means A is a subset of B, but A is not equal to B.
* **Cardinality ($|A|$)**: The number of elements in a set. For $A = {1, 3, 5, 7}$, $|A| = 4$.
* **Power Set ($P(A)$)**: The set of all possible subsets of A. If $|A| = n$, then $|P(A)| = 2^n$.


#### **Set Operations**

Let's use two example sets for the operations below:
$A = {1, 2, 3, 4}$
$B = {3, 4, 5, 6}$

##### **Union (∪)**
The union of two sets is a set containing all elements that are in **A, or in B, or in both**.

* **Notation**: $A ∪ B$
* **Example**: $A ∪ B = {1, 2, 3, 4, 5, 6}$

##### **Intersection (∩)**
The intersection of two sets is a set containing only the elements that are in **both A and B**.

* **Notation**: $A ∩ B$
* **Example**: $A ∩ B = {3, 4}$

##### **Difference (-)**
The difference $A - B$ is a set containing elements that are in **A but not in B**.

* **Notation**: $A - B$ or $A \ B$
* **Example**:
    * $A - B = {1, 2}$
    * $B - A = {5, 6}$

##### **Symmetric Difference (△)  XOR**
The symmetric difference is a set of elements that are in **either of the sets, but not in their intersection**.

* **Notation**: $A △ B$
* **Formula**: $(A ∪ B) - (A ∩ B)$
* **Example**: $A △ B = {1, 2, 5, 6}$

##### **Complement (')**
The complement is the set of elements in the **universal set (U) that are not in A**.

* **Notation**: $A'$ or $Aᶜ$
* **Example**: If $U = {1, 2, 3, 4, 5, 6, 7, 8}$, then $A' = {5, 6, 7, 8}$.

##### **Cartesian Product (×)**
The Cartesian product $A × B$ is a set of all possible **ordered pairs** where the first element is from A and the second is from B. The order matters.

* **Notation**: $A × B$
* **Example**: Let $X = {a, b}$ and $Y = {1, 2}$.
    $X × Y = {(a, 1), (a, 2), (b, 1), (b, 2)}$

## Discrete Math
### Logic
Of course. Here is the study guide for mathematical logic with all equations and symbols formatted in LaTeX.

#### **Propositions**

A **proposition** is a declarative sentence that is either **true** or **false**, but not both.

* **Examples:**
    * "Surabaya is a city in Indonesia." (True)
    * $2 + 2 = 5$ (False)
    * "The current year is 2025." (True)

* **Not Propositions:**
    * "Where are you going?" (A question)
    * "Do your homework." (A command)
    * $x > 5$ (Its truth depends on the value of $x$)


#### **Logical Operators**

Operators combine simple propositions to form compound statements. Let $p$ and $q$ be propositions.

* **AND (Conjunction): $p \land q$**
    * Means "$p$ and $q$".
    * It's only **true** if both $p$ and $q$ are true.

* **OR (Disjunction): $p \lor q$**
    * Means "$p$ or $q$".
    * It's **true** if at least one of $p$ or $q$ is true.

* **NOT (Negation): $\neg p$**
    * Means "not $p$".
    * It simply flips the truth value of $p$.

* **IF...THEN (Implication): $p \to q$**
    * Means "if $p$, then $q$". $p$ is the **hypothesis** and $q$ is the **conclusion**.
    * It is only **false** when a true hypothesis ($p$) leads to a false conclusion ($q$).

* **IF AND ONLY IF (Biconditional): $p \leftrightarrow q$**
    * Means "$p$ if and only if $q$".
    * It's **true** only when $p$ and $q$ have the same truth value.

#### Manipulating Statements: Equivalences

Two statements are **logically equivalent** if they always have the same truth value. This is denoted by $\equiv$.

* **De Morgan's Laws**: Essential for simplifying negations.
    $$\neg(p \land q) \equiv \neg p \lor \neg q$$
    $$\neg(p \lor q) \equiv \neg p \land \neg q$$

* **The Contrapositive**: An implication $p \to q$ is logically equivalent to its contrapositive.
    * **Original Statement**: $p \to q$
    * **Contrapositive**: $\neg q \to \neg p$

    Be careful not to confuse this with the **converse** ($q \to p$) or the **inverse** ($\neg p \to \neg q$), which are **not** logically equivalent to the original statement.

#### Quantifiers

Quantifiers are used to talk about properties of entire sets of objects.

* **Universal Quantifier ($\forall$)**: Means **"for all"**.
    * **Example**: $\forall x \in \mathbb{R}, x^2 \ge 0$ reads "For all real numbers $x$, $x$-squared is greater than or equal to 0."

* **Existential Quantifier ($\exists$)**: Means **"there exists"**.
    * **Example**: $\exists x \in \mathbb{Z}, x + 5 = 7$ reads "There exists an integer $x$ such that $x$ plus 5 equals 7."

### Modular Arithmetics

Modular arithmetic, often called "clock arithmetic," is a fundamental concept in discrete mathematics. It's a system of arithmetic for integers, where numbers "wrap around" after reaching a certain value, known as the **modulus**. Understanding modular arithmetic is crucial for various topics in discrete mathematics, including cryptography, number theory, and computer science. This guide will walk you through the essential concepts, operations, and theorems to help you ace your test.

#### At the Core: The Concept of Congruence

The central idea in modular arithmetic is **congruence**. Two integers, *a* and *b*, are said to be **congruent modulo *m*** if their difference (*a* - *b*) is an integer multiple of *m*. In simpler terms, *a* and *b* have the same remainder when divided by the modulus *m*.

The notation for congruence is:

$a \equiv b \pmod{m}$

This is read as "a is congruent to b modulo m."

**For example:**

* $17 \equiv 5 \pmod{12}$ because $17 - 5 = 12$, which is a multiple of 12.  Think of a clock: 17 o'clock is the same as 5 o'clock on a 12-hour clock.
* $25 \equiv 1 \pmod{4}$ because $25 - 1 = 24$, which is a multiple of 4. Both 25 and 1 leave a remainder of 1 when divided by 4.

#### Essential Operations in Modular Arithmetic

Just like regular arithmetic, you can perform addition, subtraction, and multiplication in a modular system.

##### Modular Addition

To add two numbers in modular arithmetic, you add them as you normally would and then find the remainder when the sum is divided by the modulus.

**Formula:** $(a + b) \pmod{m}$

**Example:** Calculate $(15 + 23) \pmod{7}$.

1.  Add the numbers: $15 + 23 = 38$.
2.  Find the remainder when 38 is divided by 7: $38 \div 7 = 5$ with a remainder of **3**.
3.  Therefore, $(15 + 23) \pmod{7} \equiv 3$.

##### Modular Subtraction

Modular subtraction follows a similar process. Subtract the numbers and then find the remainder.

**Formula:** $(a - b) \pmod{m}$

**Example:** Calculate $(18 - 7) \pmod{5}$.

1.  Subtract the numbers: $18 - 7 = 11$.
2.  Find the remainder when 11 is divided by 5: $11 \div 5 = 2$ with a remainder of **1**.
3.  Therefore, $(18 - 7) \pmod{5} \equiv 1$.

##### Modular Multiplication

To multiply two numbers in modular arithmetic, multiply them and then find the remainder of the product when divided by the modulus.

**Formula:** $(a \times b) \pmod{m}$

**Example:** Calculate $(9 \times 6) \pmod{4}$.

1.  Multiply the numbers: $9 \times 6 = 54$.
2.  Find the remainder when 54 is divided by 4: $54 \div 4 = 13$ with a remainder of **2**.
3.  Therefore, $(9 \times 6) \pmod{4} \equiv 2$.

#### Division and the Modular Inverse

Division in modular arithmetic is not as straightforward as the other operations. It's defined through the concept of a **modular multiplicative inverse**.

The modular multiplicative inverse of an integer *a* modulo *m* is an integer *a⁻¹* such that:

$a \times a^{-1} \equiv 1 \pmod{m}$

A modular inverse for *a* modulo *m* exists only if *a* and *m* are **coprime** (their greatest common divisor is 1).

**How to find the modular inverse?** The most common method is using the **Extended Euclidean Algorithm**. This algorithm finds integers *x* and *y* such that $ax + my = \text{gcd}(a, m)$. If $\text{gcd}(a, m) = 1$, then $ax + my = 1$. Taking this equation modulo *m*, we get $ax \equiv 1 \pmod{m}$, which means *x* is the modular inverse of *a* modulo *m*.

**Example:** Find the modular inverse of 7 modulo 26.

We need to solve $7x \equiv 1 \pmod{26}$. Using the Extended Euclidean Algorithm:
1.  $26 = 3 \times 7 + 5$
2.  $7 = 1 \times 5 + 2$
3.  $5 = 2 \times 2 + 1$

Now, working backward to express 1 in terms of 7 and 26:
1.  From the last equation: $1 = 5 - 2 \times 2$
2.  Substitute for 2 from the second equation: $1 = 5 - 2 \times (7 - 1 \times 5) = 1 \times 5 - 2 \times 7 + 2 \times 5 = 3 \times 5 - 2 \times 7$
3.  Substitute for 5 from the first equation: $1 = 3 \times (26 - 3 \times 7) - 2 \times 7 = 3 \times 26 - 9 \times 7 - 2 \times 7 = 3 \times 26 - 11 \times 7$

So, we have $(-11) \times 7 + 3 \times 26 = 1$.
Taking this modulo 26, we get $(-11) \times 7 \equiv 1 \pmod{26}$.
Since we want a positive inverse, we find the equivalent positive number for -11 modulo 26: $-11 \equiv 15 \pmod{26}$.
Therefore, the modular inverse of 7 modulo 26 is **15**.

#### Theorems in Modular Arithmetics
Here are the key equations for modular arithmetic.

* **Congruence:** $a \equiv b \pmod{m}$
* **Addition:** $(a + b) \pmod{m} = ((a \pmod{m}) + (b \pmod{m})) \pmod{m}$
* **Subtraction:** $(a - b) \pmod{m} = ((a \pmod{m}) - (b \pmod{m})) \pmod{m}$
* **Multiplication:** $(a \times b) \pmod{m} = ((a \pmod{m}) \times (b \pmod{m})) \pmod{m}$
* **Exponentiation:** $a^b \pmod{m} = ((a \pmod{m})^b) \pmod{m}$


##### Fermat's Little Theorem

This theorem provides a property for exponentiation modulo a prime number.

If *p* is a prime number, then for any integer *a* not divisible by *p*, it is true that:

$a^{p-1} \equiv 1 \pmod{p}$

A corollary to this theorem is that for any integer *a* and prime *p*:

$a^p \equiv a \pmod{p}$

**Example:** Find the remainder of $3^{100}$ when divided by 13.

Here, $p = 13$ (a prime number) and $a = 3$. According to Fermat's Little Theorem, $3^{12} \equiv 1 \pmod{13}$.
We can rewrite $3^{100}$ as $(3^{12})^8 \times 3^4$.
So, $3^{100} \equiv (1)^8 \times 3^4 \pmod{13}$.
$3^{100} \equiv 1 \times 81 \pmod{13}$.
Now, we find the remainder of 81 when divided by 13: $81 = 6 \times 13 + 3$.
Therefore, $3^{100} \equiv 3 \pmod{13}$.

##### Chinese Remainder Theorem

This theorem allows you to solve a system of simultaneous linear congruences with pairwise coprime moduli.

If you have a system of congruences:
$x \equiv a_1 \pmod{m_1}$
$x \equiv a_2 \pmod{m_2}$
...
$x \equiv a_n \pmod{m_n}$

where $m_1, m_2, ..., m_n$ are pairwise coprime, there exists a unique solution for *x* modulo $M = m_1 \times m_2 \times ... \times m_n$.

**Example:** Solve the system of congruences:
$x \equiv 2 \pmod{3}$
$x \equiv 3 \pmod{5}$
$x \equiv 2 \pmod{7}$

From the first congruence, $x$ can be $2, 5, 8, 11, 14, 17, 20, 23, ...$
From the second congruence, $x$ can be $3, 8, 13, 18, 23, ...$
From the third congruence, $x$ can be $2, 9, 16, 23, ...$

The smallest common value is **23**. The moduli are 3, 5, and 7, which are pairwise coprime. The product is $3 \times 5 \times 7 = 105$. So, the general solution is $x \equiv 23 \pmod{105}$.
### Prime Numbers
A **prime number** is a whole number greater than 1 that has exactly two distinct divisors: 1 and itself. Numbers that have more than two divisors are called **composite numbers**. For example, 7 is prime because it can only be divided by 1 and 7. In contrast, 6 is composite because its divisors are 1, 2, 3, and 6. The number 1 is neither prime nor composite.

#### How to Test for Prime Numbers in C++

Testing if a number is prime, known as a **primality test**, involves checking for divisors. Here are two common methods in C++.

#### Method 1: Simple Trial Division

This is the most straightforward approach. We check every integer from 2 up to `n-1` to see if it divides `n` evenly. If we find any such divisor, the number is not prime.

**Logic:**

1.  Numbers less than or equal to 1 are not prime.
2.  Loop from `i = 2` to `n-1`.
3.  In each iteration, check if `n % i == 0`.
4.  If it is, `n` has a divisor other than 1 and itself, so it's not prime. Return `false`.
5.  If the loop completes without finding any divisors, `n` must be prime. Return `true`.


```cpp
#include <iostream>

// Simple primality test function
bool isPrime(int n) {
    // Prime numbers are greater than 1
    if (n <= 1) {
        return false;
    }

    // Check for divisors from 2 to n-1
    for (int i = 2; i < n; ++i) {
        if (n % i == 0) {
            return false; // Found a divisor, so not prime
        }
    }

    return true; // No divisors found, so prime
}

int main() {
    int number = 29;
    if (isPrime(number)) {
        std::cout << number << " is a prime number." << std::endl;
    } else {
        std::cout << number << " is not a prime number." << std::endl;
    }
    return 0;
}
```

#### Method 2: Optimized Trial Division

The simple method is inefficient for large numbers. We can optimize it significantly. A key insight is that we only need to check for divisors up to the **square root** of the number ($\sqrt{n}$).

**Logic:**
If a number `n` can be factored into `a * b`, then one of these factors (`a` or `b`) must be less than or equal to $\sqrt{n}$. If we don't find a divisor by the time we reach $ \sqrt{n} $, we won't find one after it either.

1.  Handle the base cases (numbers \<= 1 are not prime).
2.  Loop from `i = 2` up to $\sqrt{n}$. Using `i * i <= n` is a common way to implement this without needing the `sqrt()` function from the `<cmath>` library, which avoids floating-point math.
3.  If a divisor is found, return `false`.
4.  If the loop completes, return `true`.

```cpp
#include <iostream>

// Optimized primality test function
bool isPrimeOptimized(int n) {
    // Prime numbers are greater than 1
    if (n <= 1) {
        return false;
    }

    // Check for divisors only up to the square root of n
    // We use i * i <= n to avoid calculating the square root directly
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            return false; // Found a divisor, so not prime
        }
    }

    return true; // No divisors found, so prime
}

int main() {
    int number = 97;
    if (isPrimeOptimized(number)) {
        std::cout << number << " is a prime number." << std::endl;
    } else {
        std::cout << number << " is not a prime number." << std::endl;
    }
    
    number = 100;
     if (isPrimeOptimized(number)) {
        std::cout << number << " is a prime number." << std::endl;
    } else {
        std::cout << number << " is not a prime number." << std::endl;
    }
    return 0;
}
```

This optimized version is much faster and is the standard method for basic primality testing.

#### Producing Prime Number
The Sieve of Eratosthenes is a highly efficient ancient algorithm used to find all **prime numbers** up to a specified integer `n`. It works by iteratively marking as composite (i.e., not prime) the multiples of each prime, starting with the first prime number, 2. The algorithm follows these simple steps:

1.  **Create a List:** Make a list of consecutive integers from 2 to `n`. A boolean array, say `isPrime`, is perfect for this, where `isPrime[i]` is initially set to `true` for all `i`.
2.  **Start with the First Prime:** Begin with the first prime number, `p = 2`.
3.  **Mark the Multiples:** Mark all multiples of `p` (i.e., `2*p`, `3*p`, `4*p`, ...) as not prime by setting their corresponding `isPrime` value to `false`.
4.  **Find the Next Prime:** Find the next number in your list after `p` that is still marked as prime. This new number is the next prime. Set `p` to this new number.
5.  **Repeat:** Repeat steps 3 and 4 until `p*p > n`. Any number `k` that has a prime factor greater than $\sqrt{n}$ must also have one smaller than $\sqrt{n}$, so we only need to check up to this limit.
6.  **The Result:** All the numbers that remain marked as `true` in your list are the prime numbers up to `n`.

**Example:**

1.  **List:** Create a boolean array for numbers 2 to 20, all set to `true`.
    `[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]`

2.  **p = 2:** Mark all multiples of 2 as `false`.
    `[2, 3, F, 5, F, 7, F, 9, F, 11, F, 13, F, 15, F, 17, F, 19, F]`

3.  **p = 3:** The next unmarked number is 3. Mark all multiples of 3.
    `[2, 3, F, 5, F, 7, F, F, F, 11, F, 13, F, F, F, 17, F, 19, F]`
    (Note: 6, 12, 18 were already marked).

4.  **p = 5:** The next unmarked number is 5. But $5\*5 = 25$, which is greater than our limit of 20. So, we can stop.

5.  **Final Primes:** The numbers still marked `true` are the primes: **2, 3, 5, 7, 11, 13, 17, 19**.


##### C++ Implementation

Here's how you can implement the Sieve of Eratosthenes in C++.

```cpp
#include <iostream>
#include <vector>

// Function to find all primes up to n using the Sieve of Eratosthenes
void sieveOfEratosthenes(int n) {
    // Create a boolean vector "isPrime[0..n]" and initialize
    // all entries it as true. A value in isPrime[i] will
    // finally be false if i is Not a prime, else true.
    std::vector<bool> isPrime(n + 1, true);

    // 0 and 1 are not prime numbers
    isPrime[0] = isPrime[1] = false;

    // Start with the first prime, 2, and mark its multiples
    for (int p = 2; p * p <= n; ++p) {
        // If isPrime[p] is still true, then it is a prime
        if (isPrime[p]) {
            // Update all multiples of p greater than or equal to the square of it.
            // Numbers smaller than p*p, such as 2*p, 3*p..., would have already been marked.
            for (int i = p * p; i <= n; i += p) {
                isPrime[i] = false;
            }
        }
    }

    // Print all prime numbers
    std::cout << "Prime numbers up to " << n << " are: ";
    for (int p = 2; p <= n; ++p) {
        if (isPrime[p]) {
            std::cout << p << " ";
        }
    }
    std::cout << std::endl;
}

int main() {
    int limit = 50;
    sieveOfEratosthenes(limit);
    return 0;
}
```
The Greatest Common Divisor (GCD) is the largest integer that divides two numbers, calculated efficiently using the Euclidean algorithm. The Least Common Multiple (LCM) is the smallest integer that is a multiple of two numbers, typically calculated using the GCD with the formula $lcm(a, b) = (|a \times b|) / gcd(a, b)$. These are foundational number theory concepts essential for solving many competitive programming problems.


### Greatest Common Divisor (GCD) 

The **Greatest Common Divisor**, or **GCD**, of two integers $a$ and $b$ is the largest positive integer that divides both $a$ and $b$ without leaving a remainder. It's also known as the Highest Common Factor (HCF).

For example, $gcd(12, 18) = 6$, because 6 is the largest number that divides both 12 and 18.

#### The Euclidean Algorithm

The most efficient way to compute the GCD is the **Euclidean Algorithm**. It's based on the principle that the greatest common divisor of two numbers does not change if the larger number is replaced by its difference with the smaller number. This can be extended to using the remainder, which is much faster.

The core identity is:
$$gcd(a, b) = gcd(b, a \pmod b)$$
The base case for the recursion is $gcd(a, 0) = a$.

This algorithm is extremely fast, with a time complexity of $O(\log(\min(a, b)))$.

#### C++ Example for GCD

Here's a standard recursive C++ implementation. It's elegant and commonly used in contests.

```cpp
#include <iostream>
#include <numeric> // Required for std::gcd in C++17

// Recursive implementation of Euclidean Algorithm
long long gcd(long long a, long long b) {
    // Base case: gcd(a, 0) = a
    return b == 0 ? a : gcd(b, a % b);
}

int main() {
    long long a = 54;
    long long b = 24;

    // Using our custom function
    long long result_custom = gcd(a, b);
    std::cout << "GCD of " << a << " and " << b << " is: " << result_custom << std::endl; // Output: 6

    // Using the built-in C++17 function
    // For competitive programming, it's safe and fast to use the standard library function if available.
    long long result_std = std::gcd(a, b);
    std::cout << "std::gcd result is: " << result_std << std::endl; // Output: 6

    return 0;
}
```

### Least Common Multiple (LCM)

The **Least Common Multiple**, or **LCM**, of two integers $a$ and $b$ is the smallest positive integer that is divisible by both $a$ and $b$.

For example, $lcm(12, 18) = 36$, because 36 is the smallest number that is a multiple of both 12 ($12 \times 3 = 36$) and 18 ($18 \times 2 = 36$).

#### The GCD-LCM Theorem

Calculating the LCM directly by listing multiples is inefficient. Instead, we use a fundamental theorem that connects GCD and LCM.

**Theorem:** For any two positive integers $a$ and $b$:
$$gcd(a, b) \times lcm(a, b) = a \times b$$

This allows us to easily calculate the LCM if we already know the GCD:
$$lcm(a, b) = \frac{a \times b}{gcd(a, b)}$$

This is the standard method for computing the LCM in programming contests.

#### C++ Example for LCM

To avoid potential integer overflow when calculating `a * b` (which could exceed the `long long` limit), it's safer to perform the division first. The formula can be rewritten as:
$$lcm(a, b) = \frac{a}{gcd(a, b)} \times b$$
Since $gcd(a, b)$ divides $a$, the division $(a / gcd(a, b))$ will always result in an integer.

```cpp
#include <iostream>
#include <numeric> // Required for std::lcm in C++17

// GCD function is needed for our LCM calculation
long long gcd(long long a, long long b) {
    return b == 0 ? a : gcd(b, a % b);
}

// Function to calculate LCM using the GCD-LCM theorem
long long lcm(long long a, long long b) {
    if (a == 0 || b == 0) return 0;
    // Safe way to compute to avoid overflow
    return (a / gcd(a, b)) * b;
}

int main() {
    long long a = 12;
    long long b = 18;

    // Using our custom function
    long long result_custom = lcm(a, b);
    std::cout << "LCM of " << a << " and " << b << " is: " << result_custom << std::endl; // Output: 36

    // Using the built-in C++17 function
    long long result_std = std::lcm(a, b);
    std::cout << "std::lcm result is: " << result_std << std::endl; // Output: 36

    return 0;
}
```

### Pigeon Hole Principle (PHP)
The **Pigeonhole Principle** is a simple but powerful combinatorial argument which states that if you have more items (**pigeons**) than containers (**pigeonholes**), at least one container must hold more than one item.

The principle has two common forms:

1.  **Basic Form:** If you try to place $n+1$ pigeons into $n$ pigeonholes, at least one pigeonhole must contain two or more pigeons.

2.  **Generalized Form:** If you place $N$ items into $M$ containers, then at least one container must hold at least $\lceil N/M \rceil$ items. The notation $\lceil x \rceil$ represents the ceiling function, which rounds $x$ up to the nearest integer.

Imagine you have 3 mailboxes (pigeonholes) and 4 letters (pigeons) to distribute.
- You can put the 1st letter in mailbox 1.
- You can put the 2nd letter in mailbox 2.
- You can put the 3rd letter in mailbox 3.

Now, all your mailboxes have one letter. When you go to place the 4th letter, you **must** put it into a mailbox that already contains a letter. This guarantees that at least one mailbox will end up with two letters.

This simple idea is the essence of the principle. It's often used in proofs to show that something must exist by arguing that there are not enough separate "slots" to go around.

**Example:**

This is a classic problem that perfectly illustrates the principle.

**Problem:** You have a drawer with a large number of red, blue, and green socks. You're picking socks in the dark. What is the **minimum** number of socks you must pull out to **guarantee** you have a matching pair?

**Solution:**

* **Pigeonholes:** These are the categories, which are the colors of the socks. You have 3 colors: Red, Blue, Green.
    * Number of pigeonholes, $n = 3$.

* **Pigeons:** These are the items you are picking, which are the socks themselves.

* **Applying the Principle:**
    In the worst-case scenario, you try to avoid making a pair for as long as possible.
    1.  Your first pick could be **Red**.
    2.  Your second pick could be **Blue**.
    3.  Your third pick could be **Green**.

    After picking 3 socks, you have one of each color. You have filled each of the 3 "pigeonholes" with one "pigeon."

    The very next sock you pick (the 4th sock) **must** be either red, blue, or green. No matter which color it is, it will match one of the socks you already have.

    Therefore, you need to pull out $n + 1 = 3 + 1 = 4$ socks to **guarantee** a matching pair.

### Combinatorics
Combinatorics is the area of mathematics focused on counting the number of ways to arrange, select, or combine objects. For your test, you'll mainly need to know the difference between **permutations** and **combinations**.

The key question to always ask is: **"Does the order matter?"**

#### The Two Fundamental Rules

Before getting into permutations and combinations, you need to understand two basic principles.

1.  **The Product Rule (for "AND")**
    If you have to make a sequence of choices, you **multiply** the number of options for each choice.
    * **Example:** You have 4 shirts and 3 pairs of pants. How many different outfits can you make?
        You choose a shirt **AND** you choose pants.
        * Ways = $4 \times 3 = 12$ outfits.

2.  **The Sum Rule (for "OR")**
    If you have to choose between mutually exclusive options, you **add** the number of options.
    * **Example:** A restaurant offers 5 chicken dishes or 4 beef dishes. How many options do you have for a meal?
        You choose a chicken dish **OR** a beef dish.
        * Ways = $5 + 4 = 9$ options.

#### Permutations: When Order Matters

A **permutation** is an **arrangement** of objects in a specific order. Think of it like arranging people for a photo, assigning roles (President, VP), or awarding medals.

The formula for the number of permutations of $n$ objects taken $k$ at a time is:
$$P(n, k) = \frac{n!}{(n-k)!}$$
where $n!$ (n-factorial) is $n \times (n-1) \times \dots \times 1$.

##### Example:
How many ways can you award Gold, Silver, and Bronze medals to 10 competitors?

* **Objects (n):** 10 competitors
* **Positions to fill (k):** 3 medals
* **Does order matter?** Yes, getting Gold is different from getting Silver.

So, we use permutations:
$P(10, 3) = \frac{10!}{(10-3)!} = \frac{10!}{7!} = \frac{10 \times 9 \times 8 \times 7!}{7!} = 10 \times 9 \times 8 = 720$
There are **720** different ways to award the medals.

#### Combinations: When Order Doesn't Matter

A **combination** is a **selection** of objects where the order does not matter. Think of it like picking a group for a team, choosing toppings for a pizza, or selecting a hand of cards.

The formula for the number of combinations of $n$ objects taken $k$ at a time is:
$$C(n, k) = \binom{n}{k} = \frac{n!}{k!(n-k)!}$$

##### Example:
How many ways can you choose a 3-person committee from a group of 10 people?

* **Objects (n):** 10 people
* **Group size (k):** 3 people
* **Does order matter?** No, a committee of {Alice, Bob, Carol} is the same as {Bob, Carol, Alice}.

So, we use combinations:
$C(10, 3) = \frac{10!}{3!(10-3)!} = \frac{10!}{3!7!} = \frac{10 \times 9 \times 8}{3 \times 2 \times 1} = 10 \times 3 \times 4 = 120$
There are **120** different possible committees.

#### Pascal Triangle
Pascal's Triangle serves as a ready-made calculator for **combinations**, visually representing the values of $\binom{n}{k}$. It also provides the coefficients for binomial expansions, a key concept in both combinatorics and algebra.

Pascal's Triangle is an infinite triangular array of numbers. It starts with a 1 at the top, and each subsequent number is the sum of the two numbers directly above it. The sides of the triangle are always 1.

Here are the first few rows:

```
        1               <-- Row 0
       1 1              <-- Row 1
      1 2 1             <-- Row 2
     1 3 3 1            <-- Row 3
    1 4 6 4 1           <-- Row 4
   1 5 10 10 5 1        <-- Row 5
```

The most important role of Pascal's Triangle in combinatorics is its direct relationship with the combination formula, $C(n, k)$ or $\binom{n}{k}$.

The number in the **$k$-th position** of the **$n$-th row** of the triangle is equal to $\binom{n}{k}$. **Important:** We count both rows and positions starting from 0.

**Example:**

  * **Using the formula:** $\binom{4}{2} = \frac{4\!}{2\!(4-2)\!} = \frac{24}{2 \times 2} = 6$.

  * **Using Pascal's Triangle:**

    1.  Go to **Row 4** (the line that starts `1 4 ...`).
    2.  Go to **Position 2** (the third number in that row).
    3.  The number is **6**.

    ` Row 4: 1  4   `**`6`**`   4  1 `
    ` (Pos 0, Pos 1,  `**`Pos 2`**`, Pos 3, Pos 4)`

This works for any combination. The triangle's construction rule, where a number is the sum of the two above it, is a visual representation of **Pascal's Identity**:
$$\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}$$

Pascal's Triangle also gives you the coefficients when you expand a binomial expression like $(x+y)^n$. The coefficients of the expansion are simply the numbers in the $n$-th row of the triangle.

1.  Look at **Row 3** of the triangle: `1, 3, 3, 1`.
2.  These are your coefficients. Now, write out the terms, starting with $x^3$ and decreasing the power of $x$ while increasing the power of $y$.

$$(x+y)^3 = \mathbf{1}x^3y^0 + \mathbf{3}x^2y^1 + \mathbf{3}x^1y^2 + \mathbf{1}x^0y^3$$
$$(x+y)^3 = x^3 + 3x^2y + 3xy^2 + y^3$$

This works because, for a term like $x^2y$, you are essentially asking, "In how many ways can I choose 2 'x's from the 3 factors of $(x+y)(x+y)(x+y)$?" The answer is $\binom{3}{2}$, which is 3.