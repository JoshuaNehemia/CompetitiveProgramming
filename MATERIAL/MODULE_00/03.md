# TOPIC 03: C++ for Competitive Programming

For aspirants of the International Collegiate Programming Contest (ICPC), selecting the right programming language is a critical first step. Among the plethora of options, **C++** stands out as the undisputed champion, favored by a vast majority of competitive programmers. Its combination of performance, control, and a rich library of tools makes it exceptionally well-suited for the high-pressure environment of competitive programming.

This preference for C++ becomes even clearer when contrasted with its predecessor, **C**. While C is a powerful and foundational language, C++ offers a significant leap in abstraction and utility, directly addressing the needs of a competitive programmer.

## Why C++ Dominates in ICPC

The dominance of C++ in the competitive programming circuit, including the ICPC, can be attributed to several key factors:

* **The Standard Template Library (STL):** This is arguably the most significant advantage of C++. The STL provides a rich collection of pre-implemented data structures and algorithms, saving contestants invaluable time. Instead of coding fundamental structures like dynamic arrays (`vector`), stacks, queues, or complex ones like maps and sets from scratch, a programmer can simply include the necessary headers and use these robust and efficient implementations. The STL also offers a wide range of algorithms for sorting, searching, and manipulating data, which are essential for solving algorithmic problems.

* **Performance and Speed:** ICPC problems often have strict time limits. C++, being a compiled language, offers execution speeds that are very close to low-level languages like C. This raw performance is crucial for solving problems that involve large datasets or computationally intensive algorithms within the allotted time.

* **Memory Management:** C++ provides programmers with fine-grained control over memory allocation and deallocation. While this power comes with responsibility, it allows for highly optimized memory usage, which can be a deciding factor in problems with tight memory constraints.

* **Fast Input/Output:** The `iostream` library in C++, when used with `scanf`/`printf` style I/O (or with optimizations like `ios_base::sync_with_stdio(false);` and `cin.tie(NULL);`), can handle large volumes of input and output efficiently, a common requirement in competitive programming problems.

## The C vs. C++ Distinction for Competitive Programming

While C++ is largely a superset of C, the key differences between the two are what make C++ the superior choice for the ICPC. The primary distinction lies in their programming paradigms and standard libraries.

| Feature | C | C++ | Why it Matters for ICPC |
| :--- | :--- | :--- | :--- |
| **Programming Paradigm** | Procedural | Procedural & Object-Oriented | While full-fledged OOP is not always necessary for a single contest problem, features like classes and objects allow for better code organization and reusability, which can be helpful for complex problems. |
| **Standard Library** | Limited standard library | **Extensive Standard Template Library (STL)** | The STL is a game-changer. It provides ready-to-use data structures (vectors, maps, sets) and algorithms (sort, search), saving immense time and effort during a contest. |
| **Data Abstraction** | Limited | Strong support through classes and access specifiers | Encapsulation and data hiding, core tenets of OOP supported by C++, can lead to cleaner and less error-prone code, even in the fast-paced environment of a competition. |
| **Exception Handling** | No built-in support | `try`, `catch`, `throw` | While not as commonly used in the time-sensitive nature of contests, exception handling can offer a more structured way to deal with unexpected errors compared to C's error codes. |
| **Function Overloading** | Not supported | Supported | Allows defining multiple functions with the same name but different parameters, leading to more intuitive and readable code. |

In essence, while C provides the foundational speed and low-level control, C++ builds upon this by adding a layer of high-level abstractions and a powerful standard library that are perfectly tailored to the needs of a competitive programmer. The ability to quickly implement complex logic using the STL without sacrificing performance is the primary reason why C++ is the language of choice for those aiming for success in the ICPC.

## C++ Data Types
Mastering C++ data types is crucial for writing efficient and correct solutions. 

### **Primitive Data Types**

These are the fundamental building blocks for data in C++. Their size can be platform-dependent, but the values listed are common on competitive programming judges.

| Data Type | Bytes (Typical) | Range & Use Case |
| :--- | :--- | :--- |
| `bool` | 1 | Stores `true` or `false`. Used for flags and conditions. |
| `char` | 1 | Stores a single character (e.g., 'a'). Can also be used as a tiny integer from -128 to 127. |
| `int` | 4 | The default for integers. Range: approx. $-2 \cdot 10^9$ to $2 \cdot 10^9$. Use for standard counting, indices, etc. |
| `long long` | 8 | **Essential for ICPC**. Range: approx. $-9 \cdot 10^{18}$ to $9 \cdot 10^{18}$. Use when problem constraints exceed $10^9$. |
| `float` | 4 | Single-precision floating-point number. Generally **avoided** in competitive programming due to low precision. |
| `double` | 8 | Double-precision floating-point number. The standard choice for problems involving real numbers. |
| `long double` | 10, 12, or 16 | Higher-precision floating-point. Use only when `double` is proven insufficient. |

**Important Note:** To handle non-negative numbers, you can use the `unsigned` keyword (e.g., `unsigned int`, `unsigned long long`), which roughly doubles the positive range but does not allow negative values.

### **Derived & User-Defined Types**

These types are built from primitive types and are the workhorses of C++ problem-solving.

#### **`std::string`** 
Used for handling text. It's a dynamic character array.

* **Bytes Stored**: Varies. It grows as needed.
* **Key Functions**:
    * `.size()` or `.length()`: Returns the number of characters. $O(1)$.
    * `.push_back(char c)`: Adds a character to the end.
    * `.pop_back()`: Removes the last character.
    * `.substr(pos, len)`: Gets a substring. $O(len)$.
    * `.find(string s)`: Finds the first occurrence of a substring. $O(N \cdot M)$.
    * `stoi(s)`, `stoll(s)`: Convert a string to an `int` or `long long`.

#### **`std::pair` & `std::tuple`** üéÅ
Used to group a fixed number of items together.

* **Use**: `pair` bundles two items; `tuple` bundles multiple. Great for returning multiple values from a function or as elements in data structures like `std::map` or `std::vector`.
* **Access**:
    * For `pair<T1, T2> p;`: `p.first` and `p.second`.
    * For `tuple<T1, T2, T3> t;`: `std::get<0>(t)`, `std::get<1>(t)`, etc.

### **Standard Template Library (STL) Containers**

These are the most important data structures for any competitive programmer. Your choice of container directly impacts your solution's time and memory complexity.

#### **Sequential Containers**

These containers store elements in a linear sequence.

| Container | Key Features | When to Use | Common Operations |
| :--- | :--- | :--- | :--- |
| **`std::vector`** | Dynamic array. Fast random access. | **Default choice**. Use when you need a list that can grow and requires fast element access by index. | `v[i]`, `.push_back()`, `.pop_back()`, `.size()`, `.begin()`, `.end()`, `.clear()` |
| **`std::deque`** | Double-ended queue. Fast insertion/deletion at both front and back. | When you need efficient additions/removals at both ends, like in a sliding window minimum/maximum problem. | `.push_front()`, `.pop_front()`, `.push_back()`, `.pop_back()` |
| **`std::list`** | Doubly-linked list. Slow random access. Fast insertion/deletion anywhere. | **Rarely used in ICPC**. Its performance benefits are often outweighed by cache-unfriendliness. | `.push_front()`, `.push_back()`, `.insert()`, `.erase()` |

#### **Container Adaptors**

These provide a specific interface on top of an underlying container (usually `std::deque` or `std::vector`).

| Adaptor | Behavior | When to Use | Key Operations |
| :--- | :--- | :--- | :--- |
| **`std::stack`** | Last-In, First-Out (LIFO) | For any LIFO logic: parsing expressions, backtracking, depth-first search (DFS). | `.push()`, `.pop()`, `.top()`, `.empty()` |
| **`std::queue`** | First-In, First-Out (FIFO) | For any FIFO logic: breadth-first search (BFS), simulations. | `.push()`, `.pop()`, `.front()`, `.empty()` |
| **`std::priority_queue`** | Heap. Returns the largest element (by default). | Dijkstra's algorithm, Prim's algorithm, any problem needing quick access to the min/max element. | `.push()`, `.pop()`, `.top()`, `.empty()` |

To make a `priority_queue` a min-heap (return the smallest element), declare it as:
`priority_queue<int, vector<int>, greater<int>> pq;`

#### **Associative Containers**

These containers store elements in a sorted order (tree-based) or unsorted order (hash-based) for fast lookups.

| Container | Underlying Structure | Order | Key Use Case & Complexity |
| :--- | :--- | :--- | :--- |
| **`std::set`** | Balanced Binary Search Tree | **Sorted**, Unique Elements | Stores unique elements and keeps them sorted. Great for finding unique items or when order matters. **Search/Insert/Delete: $O(\log N)$** |
| **`std::map`** | Balanced Binary Search Tree | **Sorted by Key**, Unique Keys | Stores key-value pairs. Use when you need to associate data with a key and require the keys to be sorted. **Search/Insert/Delete: $O(\log N)$** |
| **`std::unordered_set`** | Hash Table | **Unordered**, Unique Elements | The fastest way to check for the existence of an element or store unique items when order is irrelevant. **Avg. Search/Insert/Delete: $O(1)$** |
| **`std::unordered_map`** | Hash Table | **Unordered by Key**, Unique Keys | The fastest way to implement a frequency counter or associate data with a key when order is irrelevant. **Avg. Search/Insert/Delete: $O(1)$** |

**Key Functions for Associative Containers:**
* **Tree-based (`set`, `map`)**:
    * `.find(key)`: Returns an iterator to the element, or `.end()` if not found.
    * `.count(key)`: Returns 1 if present, 0 otherwise.
    * `.lower_bound(key)`: Iterator to the first element $\ge$ key.
    * `.upper_bound(key)`: Iterator to the first element $>$ key.
* **Hash-based (`unordered_set`, `unordered_map`)**:
    * Primarily use `.find()` and `.count()`. `lower_bound`/`upper_bound` do not apply as the elements are not sorted.
* **Map-specific access**: `my_map[key]` provides convenient access and insertion. Be careful: if the key doesn't exist, it creates a default-constructed value. Use `my_map.find(key)` to check for existence without creating a new element.

## Program Better with C++
In competitive programming, typing speed and code conciseness are critical. Shortening your code not only saves time but also reduces typos and can make your logic appear cleaner. Here‚Äôs how to use `typedef`, `#define`, and other tricks effectively.

### **1. Using `typedef`**

`typedef` creates an **alias** for an existing data type. It's a clean, type-safe way to shorten long type names. The compiler understands that the alias is just another name for the original type.

  * **Syntax**: `typedef <original_type> <new_alias>;`

  * **ICPC Use**: It's most commonly used for long data types and STL containers.

  * **Example**:

    ```cpp
    // Instead of typing this repeatedly...
    long long a;
    std::vector<int> b;
    std::pair<int, int> c;
    std::vector<std::pair<int, int>> d;

    // You can define aliases once at the top of your file.
    typedef long long ll;
    typedef std::vector<int> vi;
    typedef std::pair<int, int> pii;
    typedef std::vector<pii> vpii;

    // And then use the short versions.
    ll a;
    vi b;
    pii c;
    vpii d;
    ```

**Modern C++ Alternative (`using`):** The `using` keyword is now preferred for creating aliases. It's more readable and powerful, especially with templates. The syntax is very intuitive.

```cpp
using ll = long long;
using vi = std::vector<int>;
using pii = std::pair<int, int>;
```

### **2. Using `#define`**

`#define` is a preprocessor macro. It performs a direct **text substitution** before the code is compiled. It's more powerful but also more dangerous than `typedef`.

  * **Syntax**: `#define <macro_name> <replacement_text>`

  * **ICPC Use**: Used for constants, simple "function-like" shortcuts, and loops.

  * **Example**:

    ```cpp
    // For constants
    #define MOD 1000000007
    #define INF 1e9

    // For common function calls or keywords
    #define pb push_back
    #define F first
    #define S second

    vector<int> v;
    v.pb(5); // Replaced with v.push_back(5);

    pair<int, int> p = {1, 2};
    cout << p.F << " " << p.S << endl; // Replaced with p.first, p.second

    // For loops (very common)
    #define FOR(i, a, b) for (int i = (a); i < (b); ++i)
    #define REP(i, n) FOR(i, 0, n)

    REP(i, 5) { // Replaced with for (int i = (0); i < (5); ++i)
        cout << i << endl;
    }
    ```

**‚ö†Ô∏è Important Warning**: Macros are not type-safe and can lead to unexpected bugs due to simple text replacement. Always wrap arguments in parentheses in function-like macros to avoid operator precedence issues.

  * **Bad**: `#define SQUARE(x) x*x` -\> `SQUARE(2+3)` becomes `2+3*2+3 = 11`
  * **Good**: `#define SQUARE(x) ((x)*(x))` -\> `SQUARE(2+3)` becomes `((2+3)*(2+3)) = 25`

-----

### **Comparison: `typedef`/`using` vs. `#define`**

| Feature | `typedef` / `using` | `#define` |
| :--- | :--- | :--- |
| **What it does** | Creates a type alias | Performs text substitution |
| **Type Safety** | ‚úÖ **Safe**. The compiler knows the type. | ‚ùå **Not safe**. It's just text. |
| **Scope** | Respects C++ scope (e.g., inside a class/function) | Ignores scope; global from point of definition |
| **Debugging** | Easy. The debugger sees the original type name. | Hard. Errors can be cryptic as they appear after substitution. |
| **Best For** | Shortening type names (`long long`, `vector<pair<...>>`) | Constants, simple repetitive code (`pb`, loops) |


### **Guide for Competitive Programming in C++**

#### 1.  **Create a Personal Template**
This is the **single most effective trick**. Have a file ready with all your common includes, aliases, and fast I/O setup.

```cpp
#include <bits/stdc++.h> // Includes almost everything

using namespace std;

// Type Aliases
typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;

// Macros
#define F first
#define S second
#define pb push_back
#define FOR(i, a, b) for (int i = (a); i < (b); ++i)
#define REP(i, n) FOR(i, 0, n)

// Fast I/O
void fast_io() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
}

// Main problem-solving function
void solve() {
    // Your code here
}

int main() {
    fast_io();
    int t = 1;
    // cin >> t; // Uncomment for multiple test cases
    while (t--) {
        solve();
    }
    return 0;
}
```

> **Note:** `<bits/stdc++.h>` is a non-standard header available on most competitive programming judges (like Codeforces), but it may increase compilation time.
##### Fast IO
```cpp
void fast_io() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
}
```
This code block is a standard optimization in competitive programming to prevent "Time Limit Exceeded" (TLE) errors on problems with large input/output.

Here‚Äôs what each line does:
`ios_base::sync_with_stdio(false);`

By default, C++'s input/output streams (`cin`, `cout`) are synchronized with C's streams (`scanf`, `printf`). This synchronization ensures that you can mix C++ and C style I/O without the output getting jumbled. However, this synchronization adds significant overhead, making `cin` and `cout` slow.

Calling `ios_base::sync_with_stdio(false);` **disables this synchronization**, allowing `cin` and `cout` to operate independently and much faster.

**Rule**: After using this, you **should not** mix `cin`/`cout` with `scanf`/`printf`. Stick to one style.

`cin.tie(NULL);`

By default, `cin` is "tied" to `cout`. This means that before any input operation (like `cin >> var;`), the program automatically flushes the output buffer (`cout`). This is useful in interactive programs to ensure a prompt like `"Enter your name: "` appears on screen before the program waits for input.

In competitive programming, this is unnecessary overhead. You read all the input and then print the output. You don't need to flush the output buffer before every single read.

Calling `cin.tie(NULL);` (or `cin.tie(nullptr);`) **unties `cin` from `cout`**, so input operations will no longer force an output flush.

#### 2.  **Use `auto`:**
Let the compiler figure out the type for you. This is amazing for complex iterators or structured bindings.

```cpp
    map<string, vector<int>> my_map;
    // Instead of: map<string, vector<int>>::iterator it = my_map.begin();
    auto it = my_map.begin();

    // Loop through a vector
    vector<pii> points;
    for (auto& p : points) {
        cout << p.first << endl;
    }
```

#### 3.  **Structured Bindings (C++17)** 
Easily unpack `pair` or `tuple` elements into separate variables. This is incredibly clean.

```cpp
    // Old way
    pii p = {10, 20};
    int x = p.first;
    int y = p.second;

    // New way with structured bindings
    auto [x, y] = p; // Clean and fast!

    // Also works in loops
    vector<pii> points = {{1,2}, {3,4}};
    for(auto const& [x_coord, y_coord] : points) {
        cout << x_coord << " " << y_coord << endl;
    }
```

![Next topic click here!](../MODULE_01/04.md)